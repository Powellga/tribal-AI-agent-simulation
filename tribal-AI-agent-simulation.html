<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tribal AI Survival Simulation - Fixed</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #ccc;
            overflow: hidden;
        }
        
        .main-container {
            display: flex;
            height: 100vh;
        }
        
        .simulation-panel {
            width: 700px;
            background: #1a1a2e;
            padding: 15px;
            border-right: 2px solid #16213e;
        }
        
        .dashboard-panel {
            flex: 1;
            background: #0f0f23;
            overflow-y: auto;
            padding: 20px;
        }
        
        h1 {
            color: #00ff41;
            font-size: 22px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff41;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 16px;
            background: #16213e;
            color: #00ff41;
            border: 1px solid #00ff41;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }
        
        button:hover {
            background: #00ff41;
            color: #0f0f23;
            box-shadow: 0 0 10px #00ff41;
        }
        
        canvas {
            border: 2px solid #16213e;
            background: #000;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .stat-card {
            background: #16213e;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #1e3a5f;
        }
        
        .stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #00ff41;
        }
        
        .performance-monitor {
            background: #16213e;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 11px;
        }
        
        .agent-list {
            background: #16213e;
            padding: 15px;
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .agent-item {
            padding: 8px;
            margin: 5px 0;
            background: #0f0f23;
            border-radius: 4px;
            border-left: 3px solid;
            font-size: 12px;
        }
        
        .tribe-1 { border-left-color: #ff6b6b; }
        .tribe-2 { border-left-color: #4ecdc4; }
        
        #minimap {
            border: 1px solid #00ff41;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="simulation-panel">
            <h1>üèõÔ∏è Tribal AI Survival Simulation</h1>
            
            <div class="controls">
                <button id="startBtn">‚ñ∂ Start</button>
                <button id="pauseBtn">‚è∏ Pause</button>
                <button id="resetBtn">üîÑ Reset</button>
                <button id="speedBtn">Speed: Normal</button>
                <button id="debugBtn">Debug: Off</button>
            </div>
            
            <canvas id="gameCanvas"></canvas>
            
            <div class="performance-monitor">
                <div>FPS: <span id="fps">0</span> | Agents: <span id="agentCount">0</span> | Time: <span id="timeStep">0</span></div>
                <div>Avg Energy: <span id="avgEnergy">0</span> | Resources: <span id="resourceCount">0</span></div>
            </div>
            
            <canvas id="minimap"></canvas>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Red Tribe</div>
                    <div class="stat-value" id="tribe1Count">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Cyan Tribe</div>
                    <div class="stat-value" id="tribe2Count">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Births</div>
                    <div class="stat-value" id="birthCount">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Deaths</div>
                    <div class="stat-value" id="deathCount">0</div>
                </div>
            </div>
        </div>
        
        <div class="dashboard-panel">
            <h2>Top Agents</h2>
            <div class="agent-list" id="agentList"></div>
            
            <h2 style="margin-top: 20px;">Debug Info</h2>
            <div class="performance-monitor" id="debugInfo"></div>
        </div>
    </div>
    
    <script>
        // Configuration
        const WORLD_SIZE = 200; // Reduced from 500 for better performance
        const CELL_SIZE = 3;
        const VIEWPORT_WIDTH = 150;
        const VIEWPORT_HEIGHT = 120;
        const MAX_AGENTS = 200;
        const INITIAL_AGENTS_PER_TRIBE = 8;
        const INITIAL_ENERGY = 200; // Increased from 100
        const REPRODUCE_COST = 100; // Reduced from 150
        const ENERGY_PER_FOOD = 80; // Increased from 50
        const MOVE_COST = 1; // Reduced from 2
        const IDLE_COST = 0.5; // Reduced from 1
        
        // Global state
        let world = null;
        let fogOfWar = null;
        let agents = [];
        let agentMap = new Map();
        let energyPositions = new Set();
        let timeStep = 0;
        let isRunning = false;
        let debugMode = false;
        let gameSpeed = 100;
        let viewportX = 0;
        let viewportY = 0;
        let totalBirths = 0;
        let totalDeaths = 0;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let currentFps = 0;
        
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        canvas.width = VIEWPORT_WIDTH * CELL_SIZE;
        canvas.height = VIEWPORT_HEIGHT * CELL_SIZE;
        
        const minimap = document.getElementById('minimap');
        const minimapCtx = minimap.getContext('2d', { alpha: false });
        minimap.width = 200;
        minimap.height = 200;
        
        class Agent {
            constructor(x, y, type, tribe, generation = 0, parentId = null) {
                this.id = `${Date.now()}_${Math.random()}`;
                this.x = x;
                this.y = y;
                this.type = type;
                this.tribe = tribe;
                this.generation = generation;
                this.parentId = parentId;
                this.energy = INITIAL_ENERGY;
                this.age = 0;
                this.children = 0;
                this.attacks = 0;
                this.shares = 0;
                this.kills = 0;
                
                // Emotions
                this.fear = 0;
                this.frustration = 0;
                this.empathy = 0;
                
                // Memory
                this.enemies = new Set();
                this.allies = new Set();
                
                // Family tracking
                this.family = new Set();
                this.childrenIds = new Set();
                if (parentId) {
                    this.family.add(parentId);
                }
                
                // Personality traits based on type
                this.setPersonality(type);
                
                // Reveal starting area
                this.revealArea();
            }
            
            setPersonality(type) {
                switch(type) {
                    case 'aggressive':
                        this.attackRate = 0.6;
                        this.shareRate = 0.05;
                        this.exploreRate = 0.3;
                        break;
                    case 'cooperative':
                        this.attackRate = 0.05;
                        this.shareRate = 0.6;
                        this.exploreRate = 0.2;
                        break;
                    case 'balanced':
                        this.attackRate = 0.25;
                        this.shareRate = 0.25;
                        this.exploreRate = 0.25;
                        break;
                    case 'explorer':
                        this.attackRate = 0.1;
                        this.shareRate = 0.2;
                        this.exploreRate = 0.6;
                        break;
                    default:
                        this.attackRate = 0.2;
                        this.shareRate = 0.2;
                        this.exploreRate = 0.3;
                }
            }
            
            revealArea() {
                const range = 3;
                for (let dy = -range; dy <= range; dy++) {
                    for (let dx = -range; dx <= range; dx++) {
                        const nx = this.x + dx;
                        const ny = this.y + dy;
                        if (nx >= 0 && nx < WORLD_SIZE && ny >= 0 && ny < WORLD_SIZE) {
                            fogOfWar[ny * WORLD_SIZE + nx] = 0;
                        }
                    }
                }
            }
            
            update() {
                this.age++;
                this.energy -= IDLE_COST;
                
                // Decay emotions very slowly (0.1% per tick)
                this.fear *= 0.999;
                this.frustration *= 0.999;
                this.empathy *= 0.999;
                
                // Death check
                if (this.energy <= 0) {
                    return false;
                }
                
                // Find nearby entities
                const nearby = this.scanArea();
                
                // Energy-based reproduction (more energy = higher chance)
                const reproductionChance = this.energy > REPRODUCE_COST 
                    ? Math.min(0.15, 0.01 + (this.energy - REPRODUCE_COST) / 2000) // Scale from 1% to 15% based on energy
                    : 0;
                
                // Decision making based on energy and surroundings
                if (agents.length < MAX_AGENTS && Math.random() < reproductionChance) {
                    this.tryReproduce();
                } else if (this.shouldFollowFamily(nearby)) {
                    // Priority: Stay with family
                    this.moveTowardFamily(nearby);
                } else if (nearby.energy.length > 0) {
                    // Go for nearest energy
                    const target = nearby.energy[0];
                    this.moveToward(target.x, target.y);
                } else if (nearby.agents.length > 0) {
                    this.handleAgentInteraction(nearby.agents);
                } else if (Math.random() < this.exploreRate || this.energy < 50) {
                    // Explore when low on energy or randomly
                    this.explore();
                } else {
                    this.randomMove();
                }
                
                return true;
            }
            
            scanArea() {
                const range = 5;
                const result = { agents: [], energy: [], family: [] };
                
                for (let dy = -range; dy <= range; dy++) {
                    for (let dx = -range; dx <= range; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const nx = this.x + dx;
                        const ny = this.y + dy;
                        
                        if (nx >= 0 && nx < WORLD_SIZE && ny >= 0 && ny < WORLD_SIZE) {
                            const pos = ny * WORLD_SIZE + nx;
                            const dist = Math.abs(dx) + Math.abs(dy);
                            
                            // Check for energy
                            if (world[pos] === 1) {
                                result.energy.push({ x: nx, y: ny, dist: dist });
                            }
                            
                            // Check for agents
                            const key = `${nx},${ny}`;
                            if (agentMap.has(key)) {
                                const agent = agentMap.get(key);
                                result.agents.push({ agent: agent, dist: dist });
                                
                                // Check if family member
                                if (this.isFamily(agent)) {
                                    result.family.push({ agent: agent, dist: dist });
                                }
                            }
                        }
                    }
                }
                
                // Sort by distance
                result.energy.sort((a, b) => a.dist - b.dist);
                result.agents.sort((a, b) => a.dist - b.dist);
                result.family.sort((a, b) => a.dist - b.dist);
                
                return result;
            }
            
            isFamily(otherAgent) {
                // Direct relationships
                if (this.parentId === otherAgent.id ||  // Other is my parent
                    otherAgent.parentId === this.id ||  // Other is my child
                    this.childrenIds.has(otherAgent.id) ||  // Other is my child
                    otherAgent.childrenIds.has(this.id)) {  // I am other's child
                    return true;
                }
                
                // Siblings (same parent)
                if (this.parentId && this.parentId === otherAgent.parentId) {
                    return true;
                }
                
                // Extended family through family set
                if (this.family.has(otherAgent.id) || otherAgent.family.has(this.id)) {
                    return true;
                }
                
                // Check if we share any family members (cousins, etc.)
                for (let familyId of this.family) {
                    if (otherAgent.family.has(familyId)) {
                        return true;
                    }
                }
                
                return false;
            }
            
            shouldFollowFamily(nearby) {
                // Strong tendency to stay with family if they're getting too far
                if (nearby.family.length > 0) {
                    const closestFamily = nearby.family[0];
                    // If family is more than 3 cells away, prioritize following them
                    return closestFamily.dist > 3 && Math.random() < 0.8; // 80% chance to follow family
                }
                return false;
            }
            
            moveTowardFamily(nearby) {
                if (nearby.family.length > 0) {
                    // Calculate center of family group
                    let sumX = 0, sumY = 0;
                    let count = 0;
                    
                    for (let member of nearby.family.slice(0, 5)) { // Consider up to 5 closest family members
                        sumX += member.agent.x;
                        sumY += member.agent.y;
                        count++;
                    }
                    
                    if (count > 0) {
                        const centerX = Math.floor(sumX / count);
                        const centerY = Math.floor(sumY / count);
                        this.moveToward(centerX, centerY);
                    }
                }
            }
            
            handleAgentInteraction(nearbyAgents) {
                const closest = nearbyAgents[0];
                const target = closest.agent;
                const dist = closest.dist;
                
                if (dist === 1) {
                    // Adjacent - can interact
                    const same–¢ribe = target.tribe === this.tribe;
                    const isEnemy = this.enemies.has(target.id);
                    const isAlly = this.allies.has(target.id);
                    const isFamilyMember = this.isFamily(target);
                    
                    // Modify behavior based on emotions, memory, and family
                    let attackChance = this.attackRate;
                    let shareChance = this.shareRate;
                    
                    // Never attack family members
                    if (isFamilyMember) {
                        attackChance = 0;
                        shareChance *= 3; // 3x more likely to share with family
                    }
                    
                    if (!same–¢ribe) {
                        attackChance *= 2;
                        shareChance *= 0.1;
                        this.fear += 10;
                    }
                    
                    if (isEnemy) {
                        attackChance *= 1.5;
                        shareChance = 0;
                    }
                    
                    if (isAlly) {
                        attackChance *= 0.2;
                        shareChance *= 2;
                    }
                    
                    if (this.frustration > 50) {
                        attackChance *= 1.5;
                    }
                    
                    if (this.empathy > 50) {
                        shareChance *= 1.5;
                    }
                    
                    // Make decision
                    if (Math.random() < attackChance && target.energy > 20 && !isFamilyMember) {
                        this.attack(target);
                    } else if (Math.random() < shareChance && this.energy > 100) {
                        this.share(target);
                    }
                } else {
                    // Move toward or away based on relationship
                    if (this.isFamily(target)) {
                        // Always move toward family
                        this.moveToward(target.x, target.y);
                    } else if (this.enemies.has(target.id) && this.fear > 30) {
                        this.moveAway(target.x, target.y);
                    } else if (this.allies.has(target.id) || target.tribe === this.tribe) {
                        this.moveToward(target.x, target.y);
                    } else if (!target.tribe === this.tribe) {
                        if (this.fear > this.frustration) {
                            this.moveAway(target.x, target.y);
                        } else {
                            this.moveToward(target.x, target.y);
                        }
                    }
                }
            }
            
            attack(target) {
                this.attacks++;
                const damage = Math.floor(target.energy * 0.3);
                this.energy += damage;
                target.energy -= damage * 1.5; // Target loses more than attacker gains
                
                // Update emotions
                target.frustration = Math.min(100, target.frustration + 30);
                target.fear = Math.min(100, target.fear + 20);
                this.frustration = Math.max(0, this.frustration - 10); // Attacking relieves frustration
                
                // Update memory
                target.enemies.add(this.id);
                this.enemies.add(target.id);
                
                if (target.energy <= 0) {
                    this.kills++;
                }
            }
            
            share(target) {
                if (this.energy > 50) {
                    this.shares++;
                    // Share more with family members
                    const shareAmount = this.isFamily(target) ? 0.25 : 0.15;
                    const amount = Math.floor(this.energy * shareAmount);
                    this.energy -= amount;
                    target.energy += amount;
                    
                    // Update emotions (stronger bonds with family)
                    const empathyBoost = this.isFamily(target) ? 30 : 20;
                    target.empathy = Math.min(100, target.empathy + empathyBoost);
                    this.empathy = Math.min(100, this.empathy + 15);
                    target.fear = Math.max(0, target.fear - 10);
                    
                    // Update memory
                    target.allies.add(this.id);
                    this.allies.add(target.id);
                    
                    // Family members become part of extended family network
                    if (this.isFamily(target)) {
                        target.family.add(this.id);
                        this.family.add(target.id);
                    }
                }
            }
            
            tryReproduce() {
                // High energy = potentially multiple offspring
                const offspringCount = this.energy > 300 ? 2 : 1; // Double offspring if very high energy
                let successfulBirths = 0;
                
                const dirs = [[0,-1], [1,0], [0,1], [-1,0], [1,1], [-1,-1], [1,-1], [-1,1]]; // 8 directions
                const availableSpots = [];
                
                // Find all available spots
                for (let [dx, dy] of dirs) {
                    const nx = this.x + dx;
                    const ny = this.y + dy;
                    
                    if (nx >= 0 && nx < WORLD_SIZE && ny >= 0 && ny < WORLD_SIZE) {
                        const key = `${nx},${ny}`;
                        if (!agentMap.has(key)) {
                            availableSpots.push({x: nx, y: ny});
                        }
                    }
                }
                
                // Try to create offspring
                for (let i = 0; i < offspringCount && i < availableSpots.length && this.energy >= REPRODUCE_COST; i++) {
                    const spot = availableSpots[i];
                    this.energy -= REPRODUCE_COST;
                    
                    // Create child with slight mutation
                    const types = ['aggressive', 'cooperative', 'balanced', 'explorer'];
                    const childType = Math.random() < 0.9 ? this.type : types[Math.floor(Math.random() * types.length)];
                    
                    const child = new Agent(spot.x, spot.y, childType, this.tribe, this.generation + 1, this.id);
                    child.energy = REPRODUCE_COST * 0.75;
                    
                    // Inherit emotional tendencies more strongly
                    child.fear = this.fear * 0.5; // Increased from 0.3
                    child.empathy = this.empathy * 0.5;
                    child.frustration = this.frustration * 0.2;
                    
                    // Establish family connections
                    child.family.add(this.id);
                    this.childrenIds.add(child.id);
                    
                    // Children also know about their siblings
                    for (let siblingId of this.childrenIds) {
                        if (siblingId !== child.id) {
                            child.family.add(siblingId);
                        }
                    }
                    
                    // Parent's allies become child's allies (family friends)
                    for (let allyId of this.allies) {
                        if (Math.random() < 0.5) { // 50% chance to inherit alliance
                            child.allies.add(allyId);
                        }
                    }
                    
                    agents.push(child);
                    agentMap.set(`${spot.x},${spot.y}`, child);
                    this.children++;
                    totalBirths++;
                    successfulBirths++;
                }
                
                return successfulBirths > 0;
            }
            
            moveToward(tx, ty) {
                let newX = this.x;
                let newY = this.y;
                
                const dx = tx - this.x;
                const dy = ty - this.y;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    newX += dx > 0 ? 1 : -1;
                } else if (dy !== 0) {
                    newY += dy > 0 ? 1 : -1;
                }
                
                this.moveTo(newX, newY);
            }
            
            moveAway(tx, ty) {
                let newX = this.x;
                let newY = this.y;
                
                const dx = tx - this.x;
                const dy = ty - this.y;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    newX += dx > 0 ? -1 : 1;
                } else if (dy !== 0) {
                    newY += dy > 0 ? -1 : 1;
                }
                
                this.moveTo(newX, newY);
            }
            
            explore() {
                // Check if there are family members nearby
                const nearby = this.scanArea();
                if (nearby.family.length > 0 && Math.random() < 0.6) {
                    // 60% chance to explore near family instead of alone
                    const familyMember = nearby.family[0].agent;
                    
                    // Explore in the same general direction as family
                    const dx = familyMember.x > this.x ? 1 : (familyMember.x < this.x ? -1 : 0);
                    const dy = familyMember.y > this.y ? 1 : (familyMember.y < this.y ? -1 : 0);
                    
                    // Add some randomness but stay in family's general direction
                    const dirs = [[dx, dy], [dx, 0], [0, dy], [dx, -dy], [-dx, dy]];
                    const validDirs = dirs.filter(([x, y]) => {
                        const nx = this.x + x;
                        const ny = this.y + y;
                        return nx >= 0 && nx < WORLD_SIZE && ny >= 0 && ny < WORLD_SIZE;
                    });
                    
                    if (validDirs.length > 0) {
                        const [moveX, moveY] = validDirs[Math.floor(Math.random() * validDirs.length)];
                        this.moveTo(this.x + moveX, this.y + moveY);
                        return;
                    }
                }
                
                // Original exploration logic if no family nearby
                // Try to move toward unexplored areas
                const dirs = [[0,-1], [1,0], [0,1], [-1,0]];
                let bestDir = null;
                let bestUnknown = 0;
                
                for (let [dx, dy] of dirs) {
                    const nx = this.x + dx;
                    const ny = this.y + dy;
                    
                    if (nx >= 0 && nx < WORLD_SIZE && ny >= 0 && ny < WORLD_SIZE) {
                        let unknownCount = 0;
                        
                        // Count unknown cells in that direction
                        for (let r = 1; r <= 3; r++) {
                            const sx = this.x + dx * r;
                            const sy = this.y + dy * r;
                            
                            if (sx >= 0 && sx < WORLD_SIZE && sy >= 0 && sy < WORLD_SIZE) {
                                if (fogOfWar[sy * WORLD_SIZE + sx] === 1) {
                                    unknownCount++;
                                }
                            }
                        }
                        
                        if (unknownCount > bestUnknown) {
                            bestUnknown = unknownCount;
                            bestDir = [nx, ny];
                        }
                    }
                }
                
                if (bestDir) {
                    this.moveTo(bestDir[0], bestDir[1]);
                } else {
                    this.randomMove();
                }
            }
            
            randomMove() {
                const dirs = [[0,-1], [1,0], [0,1], [-1,0]];
                
                // Check if we have family nearby
                const nearby = this.scanArea();
                if (nearby.family.length > 0 && Math.random() < 0.5) {
                    // 50% chance to move toward family center instead of random
                    let sumX = 0, sumY = 0;
                    let count = 0;
                    
                    for (let member of nearby.family.slice(0, 3)) {
                        sumX += member.agent.x;
                        sumY += member.agent.y;
                        count++;
                    }
                    
                    if (count > 0) {
                        const centerX = sumX / count;
                        const centerY = sumY / count;
                        
                        // Move toward family center with some randomness
                        let dx = centerX > this.x ? 1 : (centerX < this.x ? -1 : 0);
                        let dy = centerY > this.y ? 1 : (centerY < this.y ? -1 : 0);
                        
                        // Add small random perturbation
                        if (Math.random() < 0.3) {
                            const randomDir = dirs[Math.floor(Math.random() * 4)];
                            dx = randomDir[0];
                            dy = randomDir[1];
                        }
                        
                        this.moveTo(this.x + dx, this.y + dy);
                        return;
                    }
                }
                
                // Pure random move if no family nearby
                const [dx, dy] = dirs[Math.floor(Math.random() * 4)];
                this.moveTo(this.x + dx, this.y + dy);
            }
            
            moveTo(newX, newY) {
                if (newX < 0 || newX >= WORLD_SIZE || newY < 0 || newY >= WORLD_SIZE) return;
                
                const newKey = `${newX},${newY}`;
                if (agentMap.has(newKey)) return;
                
                // Update position
                agentMap.delete(`${this.x},${this.y}`);
                this.x = newX;
                this.y = newY;
                agentMap.set(newKey, this);
                
                this.energy -= MOVE_COST;
                this.revealArea();
                
                // Check for energy at new position
                const pos = newY * WORLD_SIZE + newX;
                if (world[pos] === 1) {
                    this.energy += ENERGY_PER_FOOD;
                    world[pos] = 0;
                    energyPositions.delete(pos);
                    
                    // Bonus for exploring new areas
                    if (fogOfWar[pos] === 1) {
                        this.energy += 10;
                    }
                }
            }
        }
        
        function initializeWorld() {
            const size = WORLD_SIZE * WORLD_SIZE;
            world = new Uint8Array(size);
            fogOfWar = new Uint8Array(size);
            fogOfWar.fill(1);
            
            // Add initial energy sources near starting positions
            const addEnergyCluster = (cx, cy, count) => {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count;
                    const radius = 5 + Math.random() * 15;
                    const x = Math.floor(cx + Math.cos(angle) * radius);
                    const y = Math.floor(cy + Math.sin(angle) * radius);
                    
                    if (x >= 0 && x < WORLD_SIZE && y >= 0 && y < WORLD_SIZE) {
                        const pos = y * WORLD_SIZE + x;
                        world[pos] = 1;
                        energyPositions.add(pos);
                    }
                }
            };
            
            // Add energy near tribe starting positions
            const tribe1X = Math.floor(WORLD_SIZE * 0.25);
            const tribe1Y = Math.floor(WORLD_SIZE * 0.25);
            const tribe2X = Math.floor(WORLD_SIZE * 0.75);
            const tribe2Y = Math.floor(WORLD_SIZE * 0.75);
            
            addEnergyCluster(tribe1X, tribe1Y, 30);
            addEnergyCluster(tribe2X, tribe2Y, 30);
            
            // Add random energy clusters throughout the world
            for (let i = 0; i < 20; i++) {
                const cx = Math.floor(Math.random() * WORLD_SIZE);
                const cy = Math.floor(Math.random() * WORLD_SIZE);
                addEnergyCluster(cx, cy, 10 + Math.floor(Math.random() * 20));
            }
            
            // Clear fog around starting areas
            const clearFog = (cx, cy) => {
                for (let dy = -20; dy <= 20; dy++) {
                    for (let dx = -20; dx <= 20; dx++) {
                        const x = cx + dx;
                        const y = cy + dy;
                        if (x >= 0 && x < WORLD_SIZE && y >= 0 && y < WORLD_SIZE) {
                            fogOfWar[y * WORLD_SIZE + x] = 0;
                        }
                    }
                }
            };
            
            clearFog(tribe1X, tribe1Y);
            clearFog(tribe2X, tribe2Y);
        }
        
        function initializeAgents() {
            agents = [];
            agentMap.clear();
            totalBirths = 0;
            totalDeaths = 0;
            
            const types = ['aggressive', 'cooperative', 'balanced', 'explorer'];
            
            // Tribe 1 (Red)
            const tribe1X = Math.floor(WORLD_SIZE * 0.25);
            const tribe1Y = Math.floor(WORLD_SIZE * 0.25);
            
            for (let i = 0; i < INITIAL_AGENTS_PER_TRIBE; i++) {
                const angle = (Math.PI * 2 * i) / INITIAL_AGENTS_PER_TRIBE;
                const radius = 5 + Math.random() * 5;
                const x = Math.floor(tribe1X + Math.cos(angle) * radius);
                const y = Math.floor(tribe1Y + Math.sin(angle) * radius);
                
                if (!agentMap.has(`${x},${y}`)) {
                    const agent = new Agent(x, y, types[i % types.length], 1, 0, null);
                    agents.push(agent);
                    agentMap.set(`${x},${y}`, agent);
                }
            }
            
            // Tribe 2 (Cyan)
            const tribe2X = Math.floor(WORLD_SIZE * 0.75);
            const tribe2Y = Math.floor(WORLD_SIZE * 0.75);
            
            for (let i = 0; i < INITIAL_AGENTS_PER_TRIBE; i++) {
                const angle = (Math.PI * 2 * i) / INITIAL_AGENTS_PER_TRIBE;
                const radius = 5 + Math.random() * 5;
                const x = Math.floor(tribe2X + Math.cos(angle) * radius);
                const y = Math.floor(tribe2Y + Math.sin(angle) * radius);
                
                if (!agentMap.has(`${x},${y}`)) {
                    const agent = new Agent(x, y, types[i % types.length], 2, 0, null);
                    agents.push(agent);
                    agentMap.set(`${x},${y}`, agent);
                }
            }
        }
        
        function update() {
            if (!isRunning) return;
            
            timeStep++;
            frameCount++;
            
            // Update agents
            const survivingAgents = [];
            agentMap.clear();
            
            for (let agent of agents) {
                if (agent.update()) {
                    survivingAgents.push(agent);
                    agentMap.set(`${agent.x},${agent.y}`, agent);
                } else {
                    totalDeaths++;
                }
            }
            
            agents = survivingAgents;
            
            // Spawn new energy periodically
            if (timeStep % 10 === 0) {
                const energyToSpawn = Math.min(30, Math.floor(1000 - energyPositions.size));
                for (let i = 0; i < energyToSpawn; i++) {
                    const x = Math.floor(Math.random() * WORLD_SIZE);
                    const y = Math.floor(Math.random() * WORLD_SIZE);
                    const pos = y * WORLD_SIZE + x;
                    
                    if (world[pos] === 0 && !agentMap.has(`${x},${y}`)) {
                        world[pos] = 1;
                        energyPositions.add(pos);
                    }
                }
            }
            
            // Draw and update stats
            draw();
            if (timeStep % 5 === 0) {
                updateStats();
                drawMinimap();
            }
            
            // Continue loop
            setTimeout(() => {
                requestAnimationFrame(update);
            }, gameSpeed);
        }
        
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw world
            for (let vy = 0; vy < VIEWPORT_HEIGHT; vy++) {
                for (let vx = 0; vx < VIEWPORT_WIDTH; vx++) {
                    const worldX = viewportX + vx;
                    const worldY = viewportY + vy;
                    
                    if (worldX >= 0 && worldX < WORLD_SIZE && worldY >= 0 && worldY < WORLD_SIZE) {
                        const pos = worldY * WORLD_SIZE + worldX;
                        const screenX = vx * CELL_SIZE;
                        const screenY = vy * CELL_SIZE;
                        
                        // Draw based on fog of war
                        if (fogOfWar[pos] === 0) {
                            // Explored area
                            ctx.fillStyle = '#0a0a0a';
                            ctx.fillRect(screenX, screenY, CELL_SIZE, CELL_SIZE);
                            
                            // Draw energy
                            if (world[pos] === 1) {
                                ctx.fillStyle = '#ffaa00';
                                ctx.fillRect(screenX, screenY, CELL_SIZE - 1, CELL_SIZE - 1);
                            }
                        } else {
                            // Unexplored - solid black
                            ctx.fillStyle = '#000';
                            ctx.fillRect(screenX, screenY, CELL_SIZE, CELL_SIZE);
                        }
                    }
                }
            }
            
            // Draw agents
            for (let agent of agents) {
                if (agent.x >= viewportX && agent.x < viewportX + VIEWPORT_WIDTH &&
                    agent.y >= viewportY && agent.y < viewportY + VIEWPORT_HEIGHT) {
                    
                    const screenX = (agent.x - viewportX) * CELL_SIZE;
                    const screenY = (agent.y - viewportY) * CELL_SIZE;
                    
                    // Color based on tribe and energy
                    const energyAlpha = Math.min(1, Math.max(0.3, agent.energy / 300));
                    
                    // Draw family connections (very faint lines)
                    if (CELL_SIZE >= 4) {
                        ctx.strokeStyle = agent.tribe === 1 
                            ? `rgba(255, 107, 107, 0.1)` 
                            : `rgba(78, 205, 196, 0.1)`;
                        ctx.lineWidth = 1;
                        
                        // Draw lines to nearby family members
                        for (let other of agents) {
                            if (agent.isFamily(other) && 
                                Math.abs(agent.x - other.x) <= 5 && 
                                Math.abs(agent.y - other.y) <= 5 &&
                                other.x >= viewportX && other.x < viewportX + VIEWPORT_WIDTH &&
                                other.y >= viewportY && other.y < viewportY + VIEWPORT_HEIGHT) {
                                
                                const otherScreenX = (other.x - viewportX) * CELL_SIZE + CELL_SIZE/2;
                                const otherScreenY = (other.y - viewportY) * CELL_SIZE + CELL_SIZE/2;
                                
                                ctx.beginPath();
                                ctx.moveTo(screenX + CELL_SIZE/2, screenY + CELL_SIZE/2);
                                ctx.lineTo(otherScreenX, otherScreenY);
                                ctx.stroke();
                            }
                        }
                    }
                    
                    // Draw agent
                    if (agent.tribe === 1) {
                        ctx.fillStyle = `rgba(255, 107, 107, ${energyAlpha})`;
                    } else {
                        ctx.fillStyle = `rgba(78, 205, 196, ${energyAlpha})`;
                    }
                    
                    ctx.fillRect(screenX, screenY, CELL_SIZE - 1, CELL_SIZE - 1);
                    
                    // Mark high-energy reproducers with a special indicator
                    if (agent.energy > 300 && CELL_SIZE >= 6) {
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(screenX + CELL_SIZE/2 - 1, screenY + CELL_SIZE/2 - 1, 2, 2);
                    }
                    
                    // Show emotions if in debug mode
                    if (debugMode && CELL_SIZE >= 10) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '8px Arial';
                        if (agent.fear > 50) ctx.fillText('!', screenX, screenY + 8);
                        if (agent.frustration > 50) ctx.fillText('X', screenX + 4, screenY + 8);
                        if (agent.empathy > 50) ctx.fillText('‚ô•', screenX + 8, screenY + 8);
                    }
                }
            }
        }
        
        function drawMinimap() {
            const scale = 200 / WORLD_SIZE;
            
            minimapCtx.fillStyle = '#000';
            minimapCtx.fillRect(0, 0, 200, 200);
            
            // Draw explored areas
            for (let y = 0; y < WORLD_SIZE; y += 2) {
                for (let x = 0; x < WORLD_SIZE; x += 2) {
                    if (fogOfWar[y * WORLD_SIZE + x] === 0) {
                        minimapCtx.fillStyle = '#111';
                        minimapCtx.fillRect(x * scale, y * scale, 2 * scale, 2 * scale);
                    }
                }
            }
            
            // Draw energy
            minimapCtx.fillStyle = '#ffaa00';
            for (let pos of energyPositions) {
                const x = pos % WORLD_SIZE;
                const y = Math.floor(pos / WORLD_SIZE);
                minimapCtx.fillRect(x * scale, y * scale, scale, scale);
            }
            
            // Draw agents
            for (let agent of agents) {
                minimapCtx.fillStyle = agent.tribe === 1 ? '#ff6b6b' : '#4ecdc4';
                minimapCtx.fillRect(agent.x * scale - 1, agent.y * scale - 1, 2, 2);
            }
            
            // Draw viewport
            minimapCtx.strokeStyle = '#00ff41';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                viewportX * scale,
                viewportY * scale,
                VIEWPORT_WIDTH * scale,
                VIEWPORT_HEIGHT * scale
            );
        }
        
        function updateStats() {
            // FPS calculation
            const now = Date.now();
            if (now - lastFpsUpdate > 1000) {
                currentFps = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
            }
            
            document.getElementById('fps').textContent = currentFps;
            document.getElementById('agentCount').textContent = agents.length;
            document.getElementById('timeStep').textContent = timeStep;
            document.getElementById('resourceCount').textContent = energyPositions.size;
            
            // Calculate average energy
            const avgEnergy = agents.length > 0 
                ? Math.floor(agents.reduce((sum, a) => sum + a.energy, 0) / agents.length)
                : 0;
            document.getElementById('avgEnergy').textContent = avgEnergy;
            
            // Tribe counts
            const tribe1 = agents.filter(a => a.tribe === 1);
            const tribe2 = agents.filter(a => a.tribe === 2);
            
            document.getElementById('tribe1Count').textContent = tribe1.length;
            document.getElementById('tribe2Count').textContent = tribe2.length;
            document.getElementById('birthCount').textContent = totalBirths;
            document.getElementById('deathCount').textContent = totalDeaths;
            
            // Update agent list
            if (timeStep % 10 === 0) {
                const sortedAgents = [...agents].sort((a, b) => b.energy - a.energy);
                const agentList = document.getElementById('agentList');
                
                agentList.innerHTML = sortedAgents.slice(0, 15).map(agent => `
                    <div class="agent-item tribe-${agent.tribe}">
                        <strong>${agent.type}</strong> (Gen ${agent.generation})<br>
                        Energy: ${Math.floor(agent.energy)} | Age: ${agent.age}<br>
                        Children: ${agent.children} | Family: ${agent.family.size + agent.childrenIds.size}<br>
                        Kills: ${agent.kills} | Shares: ${agent.shares}<br>
                        Fear: ${Math.floor(agent.fear)} | Frust: ${Math.floor(agent.frustration)} | Emp: ${Math.floor(agent.empathy)}
                    </div>
                `).join('');
            }
            
            // Debug info
            if (debugMode) {
                // Calculate average family size
                const avgFamilySize = agents.length > 0 
                    ? agents.reduce((sum, a) => sum + a.family.size + a.childrenIds.size, 0) / agents.length
                    : 0;
                
                // Count family clusters (agents within 3 cells of family)
                let familyClusters = 0;
                for (let agent of agents) {
                    const nearby = agent.scanArea();
                    if (nearby.family.length > 0) {
                        familyClusters++;
                    }
                }
                
                document.getElementById('debugInfo').innerHTML = `
                    <div>World: ${WORLD_SIZE}x${WORLD_SIZE}</div>
                    <div>Energy Sources: ${energyPositions.size}</div>
                    <div>Avg Family Size: ${avgFamilySize.toFixed(1)}</div>
                    <div>Family Clusters: ${familyClusters}/${agents.length}</div>
                    <div>Avg Fear: ${Math.floor(agents.reduce((s, a) => s + a.fear, 0) / (agents.length || 1))}</div>
                    <div>Avg Frustration: ${Math.floor(agents.reduce((s, a) => s + a.frustration, 0) / (agents.length || 1))}</div>
                    <div>Avg Empathy: ${Math.floor(agents.reduce((s, a) => s + a.empathy, 0) / (agents.length || 1))}</div>
                    <div>Total Attacks: ${agents.reduce((s, a) => s + a.attacks, 0)}</div>
                    <div>Total Shares: ${agents.reduce((s, a) => s + a.shares, 0)}</div>
                `;
            }
        }
        
        // Event handlers
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!isRunning) {
                isRunning = true;
                update();
            }
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            isRunning = false;
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            isRunning = false;
            timeStep = 0;
            totalBirths = 0;
            totalDeaths = 0;
            initializeWorld();
            initializeAgents();
            draw();
            drawMinimap();
            updateStats();
        });
        
        document.getElementById('speedBtn').addEventListener('click', () => {
            const speeds = [
                { label: 'Slow', value: 200 },
                { label: 'Normal', value: 100 },
                { label: 'Fast', value: 50 },
                { label: 'Ultra', value: 10 }
            ];
            
            const current = speeds.findIndex(s => s.value === gameSpeed);
            const next = (current + 1) % speeds.length;
            gameSpeed = speeds[next].value;
            document.getElementById('speedBtn').textContent = `Speed: ${speeds[next].label}`;
        });
        
        document.getElementById('debugBtn').addEventListener('click', () => {
            debugMode = !debugMode;
            document.getElementById('debugBtn').textContent = `Debug: ${debugMode ? 'On' : 'Off'}`;
            if (!debugMode) {
                document.getElementById('debugInfo').innerHTML = '';
            }
        });
        
        // Keyboard controls for viewport
        document.addEventListener('keydown', (e) => {
            const step = 5;
            let moved = false;
            
            switch(e.key) {
                case 'ArrowUp':
                    viewportY = Math.max(0, viewportY - step);
                    moved = true;
                    break;
                case 'ArrowDown':
                    viewportY = Math.min(WORLD_SIZE - VIEWPORT_HEIGHT, viewportY + step);
                    moved = true;
                    break;
                case 'ArrowLeft':
                    viewportX = Math.max(0, viewportX - step);
                    moved = true;
                    break;
                case 'ArrowRight':
                    viewportX = Math.min(WORLD_SIZE - VIEWPORT_WIDTH, viewportX + step);
                    moved = true;
                    break;
                case ' ':
                    // Center viewport
                    viewportX = Math.floor(WORLD_SIZE / 2 - VIEWPORT_WIDTH / 2);
                    viewportY = Math.floor(WORLD_SIZE / 2 - VIEWPORT_HEIGHT / 2);
                    moved = true;
                    e.preventDefault();
                    break;
            }
            
            if (moved) {
                draw();
                drawMinimap();
            }
        });
        
        // Minimap click to jump
        minimap.addEventListener('click', (e) => {
            const rect = minimap.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const scale = WORLD_SIZE / 200;
            viewportX = Math.floor(x * scale - VIEWPORT_WIDTH / 2);
            viewportY = Math.floor(y * scale - VIEWPORT_HEIGHT / 2);
            
            viewportX = Math.max(0, Math.min(WORLD_SIZE - VIEWPORT_WIDTH, viewportX));
            viewportY = Math.max(0, Math.min(WORLD_SIZE - VIEWPORT_HEIGHT, viewportY));
            
            draw();
            drawMinimap();
        });
        
        // Initialize
        initializeWorld();
        initializeAgents();
        draw();
        drawMinimap();
        updateStats();
        
        console.log('Tribal AI Simulation Ready');
        console.log(`World: ${WORLD_SIZE}x${WORLD_SIZE}`);
        console.log(`Initial Agents: ${agents.length}`);
        console.log(`Initial Resources: ${energyPositions.size}`);
    </script>
</body>
</html>